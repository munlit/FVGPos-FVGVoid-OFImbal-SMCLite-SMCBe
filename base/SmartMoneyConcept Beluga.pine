/// ╔═══════════════════════════════╗
/// ║ 	Smart Money Concept			║
/// ║ 	@	Allen.					║
/// ║ 	@	BigBeluga				║
/// ╚═══════════════════════════════╝

//@version=5
indicator("Smart Money Concepts", "SMCb", 
	 overlay = true, 
	 max_bars_back = 5000, 
	 max_boxes_count = 500, 
	 max_labels_count = 500, 
	 max_lines_count = 500, 
	 max_polylines_count = 100)

plot(na)

//// ─────────────────────────────────────────────────────────────────────

//// ───────────────────────
/// ─── Colors ──────
//// ───────────────────────

/// ─── Standard ──
	// color.aqua								= #00BCD4
	// color.blue								= #2196F3
	// color.teal								= #00897B
	// color.green								= #4CAF50
	// color.olive								= #808000
	// color.lime								= #00E676
	// color.yellow								= #FFEB3B
	// color.orange								= #FF9800
	// color.maroon								= #880E4F
	// color.red								= #FF5252
	// color.fuchsia							= #E040FB
	// color.purple								= #9C27B0
	// color.navy								= #311B92
	// color.black								= #363A45
	// color.gray								= #787B86
	// color.silver								= #B2B5BE
	// color.white								= #FFFFFF

/// ─── Ameritrade ───
	// AmeTrWhite								= #FFFFFF								// AmeritradeWhite
	// AmeTrGrayPlatinum						= #F7F7F7								// AmeritradeGrayPlatinum
	// AmeTrGrayNickel							= #F1F1F1								// AmeritradeGrayNickel
	// AmeTrGrayNickelDark20					= #C0C0C0								// AmeritradeGrayNickelDark20
	// AmeTrGrayAluminum						= #E6E7E9								// AmeritradeGrayAluminum
	// AmeTrGrayAsh								= #D8D8D8								// AmeritradeGrayAsh
	// AmeTrGrayStone							= #999999								// AmeritradeGrayStone
	// AmeTrGrayIron							= #666666								// AmeritradeGrayIron
	// AmeTrGrayCharcoal						= #333333								// AmeritradeGrayCharcoal
	// AmeTrBlack								= #000000								// AmeritradeBlack
	// AmeTrGreenCabbage						= #EBF6E9								// AmeritradeGreenCabbage
	// AmeTrGreenLight70						= #B4D6B2								// AmeritradeGreenLight70
	// AmeTrGreenLight50						= #83BC7F								// AmeritradeGreenLight50
	// AmeTrGreenNat							= #40a829								// AmeritradeGreenNat
	// AmeTrGreenLight20						= #399333								// AmeritradeGreenLight20
	// AmeTrGreen								= #087900								// AmeritradeGreen
	// AmeTrGreenDark20							= #066000								// AmeritradeGreenDark20
	// AmeTrGreenMoss							= #BEE7D3								// AmeritradeGreenMoss
	// AmeTrGreenMint							= #6DC4BC								// AmeritradeGreenMint
	// AmeTrGreenPine							= #38635A								// AmeritradeGreenPine
	// AmeTrRedRose								= #FAD1CF								// AmeritradeRedRose
	// AmeTrRedLight50							= #E08988								// AmeritradeRedLight50
	// AmeTrRedLight20							= #CD4241								// AmeritradeRedLight20
	// AmeTrRed									= #C11312								// AmeritradeRed
	// AmeTrRedDark20							= #940F0E								// AmeritradeRedDark20
	// AmeTrOrangePeach							= #FCE7CA								// AmeritradeOrangePeach
	// AmeTrOrangeCarrot						= #ED8902								// AmeritradeOrangeCarrot
	// AmeTrOOrangeYam							= #BD5310								// AmeritradeOOrangeYam
	// AmeTrBlueFrost							= #E1EEF9								// AmeritradeBlueFrost
	// AmeTrBlueLagoon							= #316486								// AmeritradeBlueLagoon
	// AmeTrBlueNavy							= #2A5673								// AmeritradeBlueNavy
	// AmeTrBlueNcean							= #64A1C6								// AmeritradeBlueNcean
	// AmeTrPurpleEggPlant						= #732181								// AmeritradePurpleEggPlant

/// ─── Axi ───
	// AxiPrimary								= #fc404d								// AxiPrimary				/// ► ◄ ▲ ▼
	// AxiSecondary								= #282424								// AxiSecondary				/// ↑ ↓ → ←
	// AxiAccent								= #61ce70								// AxiAccent
	// Axi7a46f22								= #d11c36								// Axi7a46f22				/// @|1↓→9|1→5|.-|_789_|	/// coint|1↓→6|1→6|.-|_47_|
	// Axi1519066c								= #fc404d								// Axi1519066c				/// @|1↓→6|1↓→6|!|_7_|		/// coint|1↓→9|1→4|.!|_4_|
	// Axi3d4fa1a1								= #f0ebe3								// Axi3d4fa1a1				/// @|1↓→9|1↓→9|!|_7_|		/// coint|1↓→9|1→6|.-|_1_|		/// ok|1↓→6|1→5|.-|_147_|		/// |1↓→9|1→4|.!|_4_|
	// Axi638b46c1								= #fcd758								// Axi638b46c1				/// @|1→↑12|.-|_147_|
	// Axid07bac9								= #f9b4a8								// Axid07bac9				/// @|1→↑12|.-|_741_|
	// Axie63a114								= #2c4d5a								// Axie63a114				/// @|1→↑12|.-|_852_|		/// gt|1→↑10|.-|_52_|			/// zoo|1→↑10|.-|_82_|			/// |1→↑11|.-|_82_|
	// Axi8bf0845								= #a4d866								// Axi8bf0845				/// @|1→↑12|.-|_852_|		/// thinkors|1→↑9|_8_|2|		/// book|1→↑9|_8_|2|			/// disc|1→↑10|.-|_63_|
	// Axi75c6da1								= #282424								// Axi75c6da1				/// @|1→↑12|.-|_963_|		/// lbx|1→↑11|.-|852|
	// Axi378280f								= #45c2c7								// Axi378280f				/// @|1↓→9|1→6|.|_4_|		/// ok|1↓→6|1→4|.!|_789_|
	// Axi4de92c5								= #6caddf								// Axi4de92c5				/// @|1→↑13|.-!|_963_|		/// exch|1→↑10|.-|_85_|
	// Axi413dab8			   					= #00275d								// Axi413dab8											/// hotm|1→↑10|.-|_7_|			/// ins|1→↑10|.-|_95_|
	// Axib3fab89								= #55165c								// Axib3fab89
	// Axi548138f								= #45c2c7								// Axi548138f				/// ► ◄ ▲ ▼
	// Axi5ed9920								= #ea1616								// Axi5ed9920				/// ↑ ↓ → ←
	// Axi70f7335								= #dd0606								// Axi70f7335

/// ─── GrayScale ───
	// GraySFocus								= #2d7aed								// GrayScaleFocus
	// GraySWhite								= #fff									// GrayScaleWhite
	// GraySBlack								= #000									// GrayScaleBlack
	// GraySPrimaryBlackberry					= #2e234b								// GrayScalePrimaryBlackberry
	// GraySPrimaryBlackberry40					= rgba(46, 35, 75, .4))					// GrayScalePrimaryBlackberry40
	// GraySPrimaryBlackberry65					= rgba(46, 35, 75, .65))				// GrayScalePrimaryBlackberry65
	// GraySPrimaryCoral						= #ffb198								// GrayScalePrimaryCoral
	// GraySSecondaryForestGreen				= #244024								// GrayScaleSecondaryForestGreen
	// GraySSecondaryKeyLime					= #b5ce6f								// GrayScaleSecondaryKeyLime
	// GraySSecondaryLavender					= #c5bfe4								// GrayScaleSecondaryLavender
	// GraySSecondaryLavender40					= rgba(197, 191, 228, .4))				// GrayScaleSecondaryLavender40
	// GraySsecondaryLavender60					= rgba(197, 191, 228, .6))				// GrayScalesecondaryLavender60
	// GrayShoverWhite							= #c0bdc9								// GrayScalehoverWhite
	// GrayShoverBlackberry						= #42326b								// GrayScalehoverBlackberry
	// GraySdisabledBlackberry					= #4d4466								// GrayScaledisabledBlackberry
	// GraySactiveBlackberry					= #4d4466								// GrayScaleactiveBlackberry
	// GrayShoverCcoral							= #ffcdbd								// GrayScalehoverCcoral
	// GraySactiveCcoral						= #ff9e80								// GrayScaleactiveCcoral
	// GrayShoverGray							= #827b93								// GrayScalehoverGray
	// GrayShoverGray2							= #6d6581								// GrayScalehoverGray2
	// GraySgrayCharcoal						= #282525								// GrayScalegrayCharcoal
	// GraySgrayCharcoal70						= rgba(40, 37, 37, .7))					// GrayScalegrayCharcoal70
	// GraySgrayCharcoal80						= rgba(40, 37, 37, .8))					// GrayScalegrayCharcoal80
	// GraySgrayLight							= #f5f5f5								// GrayScalegrayLight
	// GraySgrayMedium							= #eee									// GrayScalegrayMedium
	// GraySgray70								= #696666								// GrayScalegray70
	// GraySgrayDark							= #c1c1c1								// GrayScalegrayDark
	// GraySwebSeasalt		    				= #fafafc								// GrayScalewebSeasalt
	// GraySwebDivider							= #e9e7f1								// GrayScalewebDivider
	// GraySwebBackground						= #f3f2fa								// GrayScalewebBackground
	// GraySwebSecondaryText					= #77708a								// GrayScalewebSecondaryText
	// GraySwebStroke							= #d3ceeb								// GrayScalewebStroke
	// GraySwebErrors							= #e00000								// GrayScalewebErrors
	// GraySwebService							= #2d7aed								// GrayScalewebService

/// ─── Interactive ───
	// IntAcPrimary3							= hsla(355, 85%, 46%, 0.03)		    	// InteractivePrimary3
	// IntAcPrimary5							= hsla(355, 85%, 46%, 0.05)		    	// InteractivePrimary5
	// IntAcPrimary10							= hsla(355, 85%, 46%, 0.10)		    	// InteractivePrimary10
	// IntAcPrimary20							= hsla(355, 85%, 46%, 0.20)		    	// InteractivePrimary20
	// IntAcPrimary30							= hsla(355, 85%, 46%, 0.30)		    	// InteractivePrimary30
	// IntAcPrimary40							= hsla(355, 85%, 46%, 0.40)		    	// InteractivePrimary40
	// IntAcPrimary50							= hsla(355, 85%, 46%, 0.50)		    	// InteractivePrimary50
	// IntAcPrimary60							= hsla(355, 85%, 46%, 0.60)		    	// InteractivePrimary60
	// IntAcPrimary70							= hsla(355, 85%, 46%, 0.70)		    	// InteractivePrimary70
	// IntAcPrimary80							= hsla(355, 85%, 46%, 0.80)		    	// InteractivePrimary80
	// IntAcPrimary90							= hsla(355, 85%, 46%, 0.90)		    	// InteractivePrimary90
	// IntAcPrimary								= hsla(355, 85%, 46%, 1.0)				// InteractivePrimary
	// IntAcPrimaryDark10						= hsla(355, 85%, 41%, 1.0)				// InteractivePrimaryDark10
	// IntAcPrimaryDark20						= hsla(355, 85%, 36%, 1.0)				// InteractivePrimaryDark20
	// IntAcPrimaryDark30						= hsla(355, 85%, 31%, 1.0)				// InteractivePrimaryDark30
	// IntAcPrimaryDark40						= hsla(355, 85%, 26%, 1.0)				// InteractivePrimaryDark40
	// IntAcPrimaryDark50						= hsla(355, 85%, 21%, 1.0)				// InteractivePrimaryDark50
	// IntAcSecondary3							= hsla(0, 0%, 13%, 0.03)				// InteractiveSecondary3
	// IntAcSecondary5							= hsla(0, 0%, 13%, 0.05)				// InteractiveSecondary5
	// IntAcSecondary10							= hsla(0, 0%, 13%, 0.10)				// InteractiveSecondary10
	// IntAcSecondary20							= hsla(0, 0%, 13%, 0.20)				// InteractiveSecondary20
	// IntAcSecondary30							= hsla(0, 0%, 13%, 0.30)				// InteractiveSecondary30
	// IntAcSecondary40							= hsla(0, 0%, 13%, 0.40)				// InteractiveSecondary40
	// IntAcSecondary50							= hsla(0, 0%, 13%, 0.50)				// InteractiveSecondary50
	// IntAcSecondary60							= hsla(0, 0%, 13%, 0.60)				// InteractiveSecondary60
	// IntAcSecondary70							= hsla(0, 0%, 13%, 0.70)				// InteractiveSecondary70
	// IntAcSecondary80							= hsla(0, 0%, 13%, 0.80)				// InteractiveSecondary80
	// IntAcSecondary90							= hsla(0, 0%, 13%, 0.90)				// InteractiveSecondary90
	// IntAcSecondary							= hsla(0, 0%, 13%, 1.0)			    	// InteractiveSecondary
	// IntAcSecondaryDark10						= hsla(0, 0%, 10%, 1.0)			    	// InteractiveSecondaryDark10
	// IntAcSecondaryDark20						= hsla(0, 0%, 7%, 1.0)					// InteractiveSecondaryDark20
	// IntAcSecondaryDark30						= hsla(0, 0%, 4%, 1.0)					// InteractiveSecondaryDark30
	// IntAcSecondaryDark40						= hsla(0, 0%, 1%, 1.0)					// InteractiveSecondaryDark40
	// IntAcSecondaryDark50						= hsla(0, 0%, 0%, 1.0)					// InteractiveSecondaryDark50
	// IntAcTertiary3							= hsla(202, 76%, 19%, 0.03)		    	// InteractiveTertiary3
	// IntAcTertiary5							= hsla(202, 76%, 19%, 0.05)		    	// InteractiveTertiary5
	// IntAcTertiary10							= hsla(202, 76%, 19%, 0.10)		    	// InteractiveTertiary10
	// IntAcTertiary20							= hsla(202, 76%, 19%, 0.20)		    	// InteractiveTertiary20
	// IntAcTertiary30							= hsla(202, 76%, 19%, 0.30)		    	// InteractiveTertiary30
	// IntAcTertiary40							= hsla(202, 76%, 19%, 0.40)		    	// InteractiveTertiary40
	// IntAcTertiary50							= hsla(202, 76%, 19%, 0.50)		    	// InteractiveTertiary50
	// IntAcTertiary60							= hsla(202, 76%, 19%, 0.60)		    	// InteractiveTertiary60
	// IntAcTertiary70							= hsla(202, 76%, 19%, 0.70)		    	// InteractiveTertiary70
	// IntAcTertiary80							= hsla(202, 76%, 19%, 0.80)		    	// InteractiveTertiary80
	// IntAcTertiary90							= hsla(202, 76%, 19%, 0.90)		    	// InteractiveTertiary90
	// IntAcTertiary							= hsla(202, 76%, 19%, 1.0)				// InteractiveTertiary
	// IntAcTertiaryDark10						= hsla(202, 76%, 14%, 1.0)				// InteractiveTertiaryDark10
	// IntAcTertiaryDark20						= hsla(202, 76%, 9%, 1.0)				// InteractiveTertiaryDark20
	// IntAcTertiaryDark30						= hsla(202, 76%, 4%, 1.0)				// InteractiveTertiaryDark30
	// IntAcTertiaryDark40						= hsla(202, 76%, 0%, 1.0)				// InteractiveTertiaryDark40

/// ─── Visa ───
	// VisPrimary								= #1434CB								// VisaBrandPrimary			/// ► ◄ ▲ ▼
	// VisPrimaryLight							= #3B57DE								// VisaBrandPrimaryLight	/// ↑ ↓ → ←
	// VisPrimaryDark							= #021E4C								// VisaBrandPrimaryDark
	// VisSecondary								= #FCC015								// VisaBrandSecondary		/// VT|1↓→6|1→5|!|_7_(.)|	/// coint|1↓→6|1→4|_7_.|		/// ok|1↓→6|1→4|.|_1_|			/// |1↓→6|1→4|!|_7_|		/// |1→6|1→↓6|_1_|  #910
	// VisSecondaryLight						= #FFD700								// VisaBrandSecondaryLight	/// |1↓#→6|1↓→6|_789_|-!|	/// |1↓→6|1→4|-|_74_|
	// VisSecondaryDark							= #F7B600								// VisaBrandSecondaryDark	/// @|1↓→6|1→4|!|_789_|
	// VisTertiary7								= #2C2C2C								// VisaBrandTertiary7		/// @|1↓→6|1→6|.!|_4_(.)|
	// VisTertiary6								= #5C5C5C								// VisaBrandTertiary6		/// @|1↓→9|1→6|.|_7_|		/// ()@|1↓→9|1→6|!|_7_|		/// bix|1↓→6|1→3|.-|_1_|
	// VisTertiary5								= #979797								// VisaBrandTertiary5		/// @|1↓→9|1→5|.!|_7_|
	// VisTertiary4								= #B9B9B9								// VisaBrandTertiary4		/// @|1↓→6|1→5|-|_714_|		/// bix|1↓→3|1→5|.-|_789_|
	// VisTertiary3								= #DEDEDE								// VisaBrandTertiary3		/// @|1→↓6|1→5|_741_|
	// VisTertiary2								= #EEEEEE								// VisaBrandTertiary2									/// ap|1→↓6|1→5|!|_7_|
	// VisTertiary1								= #F7F7F7								// VisaBrandTertiary1		/// @|1→↑12|.-|_741_|		/// gt|1→↑10|.-|_6_|

/// ─── Latam ───
	// LatRedBackground							= rgb(232, 17, 75)						// Latam Red Background

/// ─── Arbe Robotics ───
ARoPrimary								= #0035FF								// ArbePrimary
	// ARoPrimaryLight							= #0640FF								// ArbePrimaryLight
	// ARoSecondary		    					= #04ebff								// ArbeSecondary

/// ─── AutoX ───
	// AxPrimary								= #2253F0								// AutoXPrimary
	// AxPrimaryLight							= #0050F9								// AutoXPrimaryLight
	// AxSecondary								= #75ebc0								// AutoXSecondary

/// ─── EEG ───
	// EEGSkyBlue30								= #01EBF9								// EEGSkyBlue30
	// EEGSkyBlue40								= #00E7FD								// EEGSkyBlue40
	// EEGFucsia40								= #FF00B1								// EEGFucsia40
	// EEGFucsia50								= #FE0CB6								// EEGFucsia50

/// ─── Bright Line ───
BrLiYel10								= #FBFD73								// BrightLine Yellow Light
	// BrLiYel20								= #FFFD52								// BrightLine Yellow Light
	// BrLiYel30								= #FDF43C								// BrightLineB Yellow High
BrLiYel40								= #FEF301								// BrightLineBackground Yellow Nit
	// BrLiYel50								= #FFDB00								// BrightLineBackground Yellow Base

/// ─── Waves Beh ───
	// WavBehPink20								= #FFB7FF								// WavBehPink20
	// WavBehFucsia50							= #DF36DF								// WavBehFucsia50
	// WavBehNude10								= #FFFDDF								// WavBehNude10
	// WavBehSky70								= #06B7FE								// WavBehSky70
	// WavBehAqua50								= #0CF2F2								// WavBehAqua50

/// ─── Victoria Secret ───
	// VictSecPink20							= #EDB3DD								// VictSecPink20
	// VictSecPink50							= #E651CD								// VictSecPink50
	// VictSecFucsia50							= #EA1889								// VictSecFucsia50
	// VictSecWine30							= #C2329F								// VictSecWine30
	// VictSecWine50							= #7D1250								// VictSecWine50
	// VictSecWine60							= #7C2558								// VictSecWine60

/// ─── Mongo DB ───
	// MongoSky10								= #E3FCF7								// MongoDBSky10
	// MongoYellow50							= #FFE212								// MongoDBYellow50
	// MongoLime50								= #B1FF05								// MongoDBLime50
	// MongoGreen50								= #00ED64								// MongoDBGreen50
	// MongoGreen60								= #13AA52								// MongoDBGreen60
	// MongoGreen70								= #00684A								// MongoDBGreen70
	// MongoGreen80								= #014E3D								// MongoDBGreen80
	// MongoGray50								= #42494F								// MongoDBGray50
	// MongoGray70								= #001E2B								// MongoDBGray70
	// MongoBlack50								= #231F20								// MongoDBBlack50

/// ─── Platzi ───
PlatziGreen30							= #ADEB42								// PlatziGreen60
	// PlatziGreen40							= #85C638								// PlatziGreen60
	// PlatziGreen50							= #95CA3E								// PlatziGreen50
	// PlatziGreen60							= #98CA3F								// PlatziGreen40
PlatziBlue50							= #24385B								// PlatziBlue50
PlatziBlue70							= #121F3D								// PlatziBlue70
	// PlatziBlue80								= #0C1633								// PlatziBlue80

/// ─── Ultr ───
	// UltrBlueSky10							= #59F2E9								// UltrBlueSky10
	// UltrBlueSky20							= #39F0EA								// UltrBlueSky20
	// UltrMenta10								= #E0F9EF								// UltrMenta10
	// UltrMenta20								= #80F3EC								// UtlrMenta20
	// UltrMenta30								= #7FFFD4								// UltrMenta30
	// UltrMenta40								= #73FFCA								// UltrMenta40
	// UltrMenta50								= #9CFFD7								// UtlrMenta50
	// UltrMenta60								= #4fffc0								// UtlrMenta60
	// UltrGreen50								= #95BD5F								// UltrGreen50
	// UltrRose40								= #FFA3E3								// UltrRose
	// UltrFucsia30								= #ff6fd3								// UltrFucsia
	// UltrLyla									= #7E57C2								// UltrLyla
	// UltrLightGray							= #787B86								// UltrLightGray
	// UltrRedNit								= #de0011								// UltrRedNit
	// UltrRed									= #db004b								// UltrRed
	// UltrBlue									= #003bde								// UltrBlue
	// UltrYellow								= #f4de1a								// UltrYellow
	// UltrSkyBlue								= #12cef8								// UltrSkyBlue
	// UltrOrange								= #ff5a00								// UltrOrange

/// ─── Allen ───
AllenSky10								= #CCF8FF								// AllenSky10
	// AllenSky20								= #80F3EC								// AllenSky20
	// AllenSky50								= #01ebf9								// AllenSky50

	// AllenMint10								= #E0F9EF								// AllenMint10
AllenMint20								= #9CFFD7								// AllenMint20
	// AllenMint30								= #7FFFD4								// AllenMint30
	// AllenMint40								= #73FFCA								// AllenMint40
	// AllenMint50								= #4fffc0								// AllenMint50
AllenMint60								= #33FFAC								// AllenMint60

	// AllenFucsia30							= #E06BAA								// AllenFucsia30
AllenFucsia50							= #EA1889
AllenWine50								= #E91E63								// AllenWine50
	// AllenWine60								= #E8114B								// AllenWine60

//// ─────────────────────────────────────────────────────────────────────

//// ───────────────────────
/// ─── SmcB ────
/// ─── Const ──
//// ───────────────────────

MSGGroup					= "Smart Money Concept Belu - ESTRUCTURA DEL MERCADO"
VBGGroup					= "ORDER BLOCKS VOLUMÉTRICO"
VFvgGroup					= "FAIR VALUE GAP"
VSwingGroup					= "PATRÓN de QUIEBRE de SWING"
VLiqCoGroup					= "LIQUIDITY CONCEPTS"

IDT							= "[Entrada] Fecha de inicio de la estructura interna"

OBTTool						= "Mostrar actividad interna de compra y venta"
OBDTool						= "Mostrar el último número del orderblock"
OBMTool						= "[Longitud] Use la longitud para ajustar la cordinación de los bloques de pedidos\n[Completo] Usar todo el cuerpo de la vela"

MsWinTool					= "Cálculo de la estructura de mercado SWING para mejorar el tiempo de velocidad de la memoria"
SwingLimTool				= "[ENTRADA] Limitar la estructura SWING a las barras traseras"
MapStyTool					= "Mostrar estructura de mapeo"
CandLecTool					= "Vela de color basada en un sistema de detección de tendencias"
ShowHLTool					= "Mostrar Volumétrica Fuerte/Débil Alta/Baja"
BuildSwTool					= "Construir un barrido en la estructura del mercado"
FvgSrcTool					= "[Cerrar] Usar el cierre del cuerpo como disparador\n\n[Mecha] Usar el punto extremo del cuerpo como disparador"
OBMitiTool					= "Método de mitigación para cuándo activar order blocks"
DevCssTool					= "Mostrar proyección de desviación SFP"

SmcColorInUp				= AllenMint60
SmcColorInDn				= AllenSky10
SmcColorLiUp				= ARoPrimary
SmcColorLiDn				= AllenWine50

SmcColorBreakUp				= AllenFucsia50
SmcColorBreakDn				= ARoPrimary

SmcColorMapEs				= AllenMint20

SmcColorFvgUp				= BrLiYel10
SmcColorFvgDn				= BrLiYel40
SmcColorDSwing				= BrLiYel40

SmcColorGreen				= PlatziGreen30
SmcColorFucsia				= AllenFucsia50
SmcColorYellHigh			= BrLiYel10
SmcColorYell				= BrLiYel40
SmcColorBlue				= ARoPrimary

//// ───────────────────────
/// ─── SmcB ────
/// ─── Inputs ──
//// ───────────────────────

bool windowsis				= input.bool	(true,							title = "Espacio",							inline = "kla",		group = MSGGroup)
int mswindow				= input.int		(5000,							title = "",									inline = "kla",		group = MSGGroup,		minval = 1000,	tooltip = MsWinTool)
bool showSwing				= input.bool	(true,							title = "Swing",							inline = "scss",	group = MSGGroup)
int swingLimit				= input.int		(100,							title = "",									inline = "scss",	group = MSGGroup,		minval = 10,	maxval = 200,	tooltip = SwingLimTool)
color swingcssup			= input.color	(color.new(SmcColorInUp, 50),	title = "",									inline = "scss",	group = MSGGroup)
color swingcssdn			= input.color	(color.new(SmcColorInDn, 50),	title = "",									inline = "scss",	group = MSGGroup)

bool showMapping			= input.bool	(false,							title = "Mapeo de estructura",				inline = "mapping",	group = MSGGroup)
string mappingStyle			= input.string	("····",						title = "",									inline = "mapping",	group = MSGGroup,
	  options				= ["⎯⎯⎯⎯", "----", "····"])
color mappingcss			= input.color	(color.new(SmcColorMapEs, 40),	title = "",									inline = "mapping",	group = MSGGroup,						tooltip = MapStyTool)
bool candlecss				= input.bool	(false,							title = "Barras de Color",					inline = "txt",		group = MSGGroup,						tooltip = CandLecTool)
string mstext				= input.string	("Tiny",						title = "",									inline = "txt",		group = MSGGroup,
	  options				= ["Tiny", "Small", "Normal", "Large", "Huge"])
string msmode				= input.string	("Puntos estrechos",			title = "Lógica algorítmica",				inline = "node",	group = MSGGroup,
	  options				= ["Puntos estremos", "Puntos estrechos"])
int mslen					= input.int		(defval = 5,					title = "",									inline = "node",	group = MSGGroup,		minval = 2)

bool showhl					= input.bool	(true,							title = "Fuerte/Débil HL",					inline = "hl",		group = MSGGroup,						tooltip = ShowHLTool)
bool buildsweep				= input.bool	(false,							title = "Mostrar Sweep (x)",				inline = "znc",		group = MSGGroup,						tooltip = BuildSwTool)
bool msbubble				= input.bool	(true,							title = "Burbujas",							inline = "bubbles", group = MSGGroup)

bool obshow					= input.bool	(true,							title = "Mostrar ultimos",					inline = "obshow",	group = VBGGroup,						tooltip = OBDTool)
int oblast					= input.int		(defval = 5,					title = "",									inline = "obshow",	group = VBGGroup,		minval = 0)
color obupcs				= input.color	(color.new(SmcColorInUp, 90),	title = "",									inline = "obshow",	group = VBGGroup)
color obdncs				= input.color	(color.new(SmcColorInDn, 90),	title = "",									inline = "obshow",	group = VBGGroup)
bool obshowactivity			= input.bool	(false,							title = "Mostrar actividad de Compra/Venta",inline = "act",		group = VBGGroup,						tooltip = OBTTool)
color obactup				= input.color	(color.new(SmcColorInUp, 75),	title = "",									inline = "act",		group = VBGGroup)
color obactdn				= input.color	(color.new(SmcColorInDn, 75),	title = "",									inline = "act",		group = VBGGroup)

obshowbb					= input.bool	(true,							title = "Mostrar Breakers",					inline = "bb",		group = VBGGroup)
color bbup					= input.color	(color.new(SmcColorBreakUp, 88),title = "",									inline = "bb",		group = VBGGroup)
color bbdn					= input.color	(color.new(SmcColorBreakDn, 88),title = "",									inline = "bb",		group = VBGGroup)
obmode						= input.string	("Longitud",					title = "Contrucción",						inline = "atr",		group = VBGGroup,
	  options				= ["Longitud", "Full"],
	  tooltip				= OBMTool)
len							= input.int		(5,								title = "",									inline = "atr",		group = VBGGroup,		minval = 1)
obmiti						= input.string	("Cierre",						title = "Metodo de Mitigación",									group = VBGGroup,	
	  options				= ["Cierre", "Mecha", "Avg"],
	  tooltip				= OBMitiTool)
obtxt						= input.string	("Small",						title = "Tamaño Metrica",					inline = "txt",		group = VBGGroup,
	  options				= ["Tiny", "Small", "Normal", "Large", "Huge", "Auto"])

showmetric					= input.bool	(true,							title = "Mostrar Metricas",										group = VBGGroup)
showline					= input.bool	(true,							title = "Mostrar Linea media",									group = VBGGroup)
overlap						= input.bool	(false,							title = "Ocultar superposición",			inline = "ov",		group = VBGGroup)
wichlap						= input.string	("Reciente",					title = "",									inline = "ov",		group = VBGGroup,
	  options				= ["Reciente", "Antiguo"])

fvg_enable					= input.bool	(true,							title = "",									inline = "1",		group = VFvgGroup)
what_fvg					= input.string	("FVG",							title = "",									inline = "1",		group = VFvgGroup, 
	  options				= ["FVG", "Breakers"])
fvg_num						= input.int(5,									title = "Mostrar ultimos",					inline = "1a",		group = VFvgGroup,		minval = 0)
fvg_upcss					= input.color	(color.new(SmcColorFvgUp, 88),	title = "",									inline = "1",		group = VFvgGroup)
fvg_dncss					= input.color	(color.new(SmcColorFvgDn, 90),	title = "",									inline = "1",		group = VFvgGroup)
fvgbbup						= input.color	(color.new(SmcColorFvgUp, 90),	title = "",									inline = "1",		group = VFvgGroup)
fvgbbdn						= input.color	(color.new(SmcColorFvgDn, 92),	title = "",									inline = "1",		group = VFvgGroup)
fvg_src						= input.string	("Cierre",						title = "Mitigación",						inline = "3",		group = VFvgGroup, 
	  options				= ["Cierre", "Mecha", "Avg"],
	  tooltip				= FvgSrcTool) 
fvgthresh					= input.float	(0, 							title = "Umbral",							inline = "asd",		group = VFvgGroup,		minval = 0,		maxval = 2,	step = 0.1)
fvgoverlap					= input.bool	(true,							title = "Ocultar superposición",								group = VFvgGroup)
fvgline						= input.bool	(false,							title = "Mostrar Linea media",									group = VFvgGroup)
fvgextend					= input.bool	(false,							title = "Extender FVG",											group = VFvgGroup)
dispraid					= input.bool	(true,							title = "Mostrar Raids",					inline = "raid",	group = VFvgGroup)

dispSFP						= input.bool	(true,							title = "Mostrar ultimos",					inline = "sfp",		group = VSwingGroup)
sfpshow						= input.int		(5,								title = "",									inline = "sfp",		group = VSwingGroup,	minval = 0)
showdev						= input.bool	(true,							title = "Area de desviación",				inline = "dev",		group = VSwingGroup)
brsfpcs						= input.color	(color.new(SmcColorDSwing, 65),	title = "",									inline = "sfp",		group = VSwingGroup)
blsfpcs						= input.color	(color.new(SmcColorDSwing, 55),	title = "",									inline = "sfp",		group = VSwingGroup)
spfuselen					= input.bool	(true,							title = "Longitud",							inline = "sfx",		group = VSwingGroup)
sfplen						= input.int		(5,								title = "",									inline = "sfx",		group = VSwingGroup,	minval = 0)
sfpfilter					= input.string	("Counter Trade",				title = "Filtrado",							inline = "sfp1",	group = VSwingGroup,
	  options				= ["None", "Trend Following", "Counter Trade"])
sfpthresh					= input.float	(1,								title = "Umbral",							inline = "sfp2",	group = VSwingGroup,	minval = 0.1,	maxval = 2,	step = 0.1)
devstyle					= input.string	("⎯⎯⎯⎯",						title = "",									inline = "dev",		group = VSwingGroup,
	  options				= ["⎯⎯⎯⎯", "----", "····"])
devcss						= input.color	(color.new(SmcColorDSwing, 50),	title = "",									inline = "dev",		group = VSwingGroup,
	  tooltip				= DevCssTool)
devsize						= input.string	("Small",						title = "Tamaño de texto",					inline = "ak",		group = VSwingGroup,
	  options				= ["Tiny", "Small", "Normal", "Large", "Huge", "Auto"],
	  tooltip				= "Text Size")
devlvl						= input.bool	(true,							title = "Mostrar Nivel",										group = VSwingGroup)
devfill						= input.bool	(true,							title = "Rellenar area",										group = VSwingGroup)
ehlshow						= input.bool	(true,							title = "Equal H&L",						inline = "ehl",		group = VLiqCoGroup)
ehlmode						= input.string	("Short-Term",					title = "",									inline = "ehl",		group = VLiqCoGroup,
	  options				= ["Short-Term", "Mid-Term", "Long-Term"])
ehldowncs					= input.color	(color.new(SmcColorYell,75),	title = "",									inline = "ehl",		group = VLiqCoGroup)
ehlupcs						= input.color	(color.new(SmcColorBlue, 75),	title = "",									inline = "ehl",		group = VLiqCoGroup)
liqprint					= input.bool	(true,							title = "Impresiones de liquidez",			inline = "print",	group = VLiqCoGroup)
printupcs					= input.color	(color.new(SmcColorYellHigh,50),title = "",									inline = "print",	group = VLiqCoGroup)
printdowncs					= input.color	(color.new(SmcColorBlue,50),	title = "",									inline = "print",	group = VLiqCoGroup)
showside					= input.bool	(true,							title = "Buyside & Sellside", 				inline = "side",	group = VLiqCoGroup)
sidemode					= input.string	("Area",						title = "",									inline = "side",	group = VLiqCoGroup,
	  options				= ["Area", "Line"])
buysidecss					= input.color	(color.new(SmcColorLiUp, 75),	title = "",									inline = "side",	group = VLiqCoGroup)
sidesidecss					= input.color	(color.new(SmcColorLiDn, 75),	title = "",									inline = "side",	group = VLiqCoGroup)
showzone					= input.bool	(true, "Sweep Area",			title = "Mostrar zona de liquidación Sweep",inline = "sz",		group = VLiqCoGroup)
zonethresh					= input.int		(10,							title = "",									inline = "sz",		group = VLiqCoGroup,	minval = 2)
upzone						= input.color	(color.new(SmcColorInUp, 80),	title = "",									inline = "sz",		group = VLiqCoGroup)
dnzone						= input.color	(color.new(SmcColorInDn, 80),	title = "",									inline = "sz",		group = VLiqCoGroup)

//// ───────────────────────
/// ─── SmcB ────
/// ─── UDT ──
//// ───────────────────────

type hqlzone
	box   pbx
	box   ebx
	box   lbx
	label plb
	label elb
	label lbl

type Zphl
	line   top
	line   bottom
	label  top_label
	label  bottom_label
	bool   stopcross
	bool   sbottomcross
	bool   itopcross
	bool   ibottomcross
	string txtup
	string txtdn
	float  topy
	float  bottomy
	float  topx
	float  bottomx
	float  tup
	float  tdn
	int    tupx
	int    tdnx
	float  itopy
	float  itopx
	float  ibottomy
	float  ibottomx
	float  uV
	float  dV

type entered
	bool normal  = false
	bool breaker = false

type store
	line    [] ln
	label   [] lb
	box     [] bx
	linefill[] lf

type structure
	int    zn
	float  zz
	float  bos
	float  choch
	int    loc
	int    temp
	int    trend
	int    start
	float  main
	int    xloc
	bool   upsweep
	bool   dnsweep
	string txt = na
	
type drawms
	int    x1
	int    x2
	float  y
	string txt
	color  css
	string style

type ob
	bool  bull
	float top
	float btm
	float avg
	int   loc
	color css
	float vol
	int   dir
	int   move
	int   blPOS
	int   brPOS
	int   xlocbl
	int   xlocbr
	bool  isbb   = false
	int   bbloc

type FVG
	float top     = na
	float btm     = na
	int   loc     = bar_index
	bool  isbb    = false
	int   bbloc   = na
	bool  israid  = false
	float raidy   = na
	int   raidloc = na
	int   raidx2  = na
	bool  active  = false
	color raidcs  = na

type SFP
	float y
	int   loc
	float ancor

type sfpbuildlbl
	int    x
	float  y
	string style
	color  css
	string txt

type sfpbuildline
	int   x1
	int   x2
	float y
	color css
	float ancor
	int   loc

type equalbuild
	int    x1
	float  y1
	int    x2
	float  y2
	color  css
	string style

type equalname
	int    x
	float  y
	string txt
	color  css
	string style

type ehl
	float pt
	int   t
	float pb
	int   b

type sellbuyside
	float  top
	float  btm
	int    loc
	color  css
	string txt
	float  vol

type timer
	bool start = false
	int  count = 0

//// ───────────────────────
/// ─── SmcB ────
/// ─── Setup ──
//// ───────────────────────

var store bin = store.new(
				   array.new<  line  >()
				 , array.new<  label >()
				 , array.new<   box  >()
				 , array.new<linefill>()
				 )

var entered blobenter   = entered.new()
var entered brobenter   = entered.new()

var entered blfvgenter  = entered.new()
var entered brfvgenter  = entered.new()

var entered blarea      = entered.new()
var entered brarea      = entered.new()

var timer   lc          = timer.new  ()

if barstate.islast
	for obj in bin.ln
		obj.delete()
	for obj in bin.lb
		obj.delete()
	for obj in bin.bx
		obj.delete()
	for obj in bin.lf
		obj.delete()
	
	bin.ln.clear()
	bin.lb.clear()
	bin.bx.clear()
	bin.lf.clear()

invcol = #ffffff00

float atr = (ta.atr(200) / (5/len))

//// ───────────────────────
/// ─── SmcB ────
/// ─── Utility ──
//// ───────────────────────

method txSz(string s) =>
	out = switch s
		"Tiny"   => size.tiny
		"Small"  => size.small
		"Normal" => size.normal
		"Large"  => size.large
		"Huge"   => size.huge
		"Auto"   => size.auto
	out

method lstyle(string style) =>
	out = switch style
		'⎯⎯⎯⎯'  => line.style_solid
		'----'  => line.style_dashed
		'····'  => line.style_dotted

ghl() => [high[2], low[2], close[1], open[1], close, open, high, low, high[1], low[1], ta.atr(200)]

method IDMIDX(bool use_max, int loc) =>

	min = 99999999.
	max = 0.
	idx = 0

	if use_max
		for i = 0 to (bar_index - loc) 
			max := math.max(high[i], max)
			min := max == high[i] ? low[i] : min
			idx := max == high[i] ? i : idx

	else
		for i = 0 to (bar_index - loc) 
			min := math.min(low[i], min)
			max := min == low[i] ? high[i] : max
			idx := min == low[i] ? i : idx

	idx

SFPData() => [high, high[1] , high[2] , low, low[1] , low[2] , close, volume, time, bar_index , time[1]] 

SFPcords() =>
	RealTF = barstate.isrealtime ? 0 : 1
	[h, h1, h2, l, l1, l2, c, v, t, n, t1] =  SFPData()
			
	[h[RealTF], h1[RealTF], h2[RealTF], l[RealTF], l1[RealTF], l2[RealTF], c[RealTF], v[RealTF], t[RealTF], n[RealTF], t1[RealTF]]


method find(structure ms, bool use_max, bool sweep, bool useob) =>
	min = 99999999.
	max = 0.
	idx = 0
	if not sweep
		if ((bar_index - ms.loc) - 1) > 0
			if use_max
				for i = 0 to (bar_index - ms.loc) - 1
					max := math.max(high[i], max)
					min := max ==   high[i] ? low[i] : min
					idx := max ==   high[i] ?      i : idx

				if useob
					if high[idx + 1] > high[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

			else
				for i = 0 to (bar_index - ms.loc) - 1
					min := math.min(low[i], min)
					max := min ==   low[i] ? high[i] : max
					idx := min ==   low[i] ?       i : idx

				if useob
					if low[idx + 1] < low[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

		else
			if use_max
				for i = 0 to (bar_index - ms.loc)
					max := math.max(high[i], max)
					min := max ==   high[i] ? low[i] : min
					idx := max ==   high[i] ?      i : idx

				if useob
					if high[idx + 1] > high[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

			else
				for i = 0 to (bar_index - ms.loc)
					min := math.min(low[i], min)
					max := min ==   low[i] ? high[i] : max
					idx := min ==   low[i] ?       i : idx

				if useob
					if low[idx + 1] < low[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

	else
		if ((bar_index - ms.xloc) - 1) > 0
			if use_max
				for i = 0 to (bar_index - ms.xloc) - 1
					max := math.max(high[i], max)
					min := max ==   high[i] ? low[i] : min
					idx := max ==   high[i] ?      i : idx

				if useob
					if high[idx + 1] > high[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

			else
				for i = 0 to (bar_index - ms.xloc) - 1
					min := math.min(low[i], min)
					max := min ==   low[i] ? high[i] : max
					idx := min ==   low[i] ?       i : idx

				if useob
					if low[idx + 1] < low[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

		else
			if use_max
				for i = 0 to (bar_index - ms.xloc)
					max := math.max(high[i], max)
					min := max ==   high[i] ? low[i] : min
					idx := max ==   high[i] ?      i : idx

				if useob
					if high[idx + 1] > high[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

			else
				for i = 0 to (bar_index - ms.xloc)
					min := math.min(low[i], min)
					max := min ==   low[i] ? high[i] : max
					idx := min ==   low[i] ?       i : idx

				if useob
					if low[idx + 1] < low[idx]
						max := high[idx + 1]
						min := low [idx + 1]
						idx :=      idx + 1

	idx

method fnOB(ob[] block, bool bull, float cords, int idx) =>
	switch bull
		true =>
			blobenter.normal  := false
			blobenter.breaker := false
			block.unshift(
				 ob.new(
					   true
					 , cords
					 , low   [idx]
					 , math.avg(cords, low[idx])
					 , time  [idx]
					 , obupcs
					 , volume[idx]
					 , close [idx]  > open[idx] ? 1 : -1
					 , 1
					 , 1
					 , 1
					 , time  [idx]
					 )
					 )

		false =>
			brobenter.normal  := false
			brobenter.breaker := false
			block.unshift(
				 ob.new(
					   false
					 , high  [idx]
					 , cords
					 , math.avg(cords, high[idx])
					 , time  [idx]
					 , obdncs
					 , volume[idx]
					 , close [idx]   > open[idx] ? 1 : -1
					 , 1
					 , 1
					 , 1
					 , time  [idx]
					 )
					 )

method mitigated(ob[] block) =>
	if barstate.isconfirmed
		for [i, stuff] in block
			if not stuff.isbb
				switch stuff.bull
					true =>
						if obmiti == "Cierre" ? math.min(close, open) < stuff.btm : obmiti == "Mecha" ? low  < stuff.btm : obmiti == "Avg" ? low  < stuff.avg : na
							stuff.isbb          := true
							stuff.bbloc         := time
							if not obshowbb
								block.remove(i)

					false =>
						if obmiti == "Cierre" ? math.max(close, open) > stuff.top : obmiti == "Mecha" ? high > stuff.top : obmiti == "Avg" ? high > stuff.avg : na
							stuff.isbb          := true
							stuff.bbloc         := time
							if not obshowbb
								block.remove(i)

			else
				switch stuff.bull
					true =>
						if obmiti == "Cierre" ? math.max(close, open) > stuff.top : obmiti == "Mecha" ? high > stuff.top : obmiti == "Avg" ? high > stuff.avg : na
							
							block.remove(i)

					false =>
						if obmiti == "Cierre" ? math.min(close, open) < stuff.btm : obmiti == "Mecha" ? low  < stuff.btm : obmiti == "Avg" ? low  < stuff.avg : na
							
							block.remove(i)

overlap(ob[] bull, ob[] bear) =>
	if bull.size() > 1
		for i       = bull.size() - 1 to 1
			stuff   = bull.get(i)
			current = bull.get(0)
			v       = wichlap == "Reciente" ? i : 0
			switch
				stuff.btm > current.btm and stuff.btm < current.top => bull.remove(v)
				stuff.top < current.top and stuff.btm > current.btm => bull.remove(v)
				stuff.top > current.top and stuff.btm < current.btm => bull.remove(v)
				stuff.top < current.top and stuff.top > current.btm => bull.remove(v)

	if bear.size() > 1
		for i       = bear.size() - 1 to 1
			stuff   = bear.get(i)
			current = bear.get(0)
			v       = wichlap == "Reciente" ? i : 0
			switch
				stuff.btm > current.btm and stuff.btm < current.top => bear.remove(v)
				stuff.top < current.top and stuff.btm > current.btm => bear.remove(v)
				stuff.top > current.top and stuff.btm < current.btm => bear.remove(v)
				stuff.top < current.top and stuff.top > current.btm => bear.remove(v)

	if bull.size() > 0 and bear.size() > 0
		for i       = bull.size() - 1 to 0
			stuff   = bull.get(i)
			current = bear.get(0)
			v       = wichlap == "Reciente" ? 0 : i
			switch
				stuff.btm > current.btm and stuff.btm < current.top => bull.remove(v)
				stuff.top < current.top and stuff.btm > current.btm => bull.remove(v)
				stuff.top > current.top and stuff.btm < current.btm => bull.remove(v)
				stuff.top < current.top and stuff.top > current.btm => bull.remove(v)

	if bull.size() > 0 and bear.size() > 0
		for i       = bear.size() - 1 to 0
			stuff   = bear.get(i)
			current = bull.get(0)
			v       = wichlap == "Reciente" ? 0 : i
			switch
				stuff.btm > current.btm and stuff.btm < current.top => bear.remove(v)
				stuff.top < current.top and stuff.btm > current.btm => bear.remove(v)
				stuff.top > current.top and stuff.btm < current.btm => bear.remove(v)
				stuff.top < current.top and stuff.top > current.btm => bear.remove(v)

overlapFVG(FVG[] blFVG, FVG[] brFVG) =>
	if blFVG.size() > 1
		for i       = blFVG.size() - 1 to 1
			stuff   = blFVG.get(i)
			current = blFVG.get(0)
			switch
				stuff.btm > current.btm and stuff.btm < current.top => blFVG.remove(i)
				stuff.top < current.top and stuff.btm > current.btm => blFVG.remove(i)
				stuff.top > current.top and stuff.btm < current.btm => blFVG.remove(i)
				stuff.top < current.top and stuff.top > current.btm => blFVG.remove(i)

	if brFVG.size() > 1
		for i       = brFVG.size() - 1 to 1
			stuff   = brFVG.get(i)
			current = brFVG.get(0)
			switch
				stuff.btm > current.btm and stuff.btm < current.top => brFVG.remove(i)
				stuff.top < current.top and stuff.btm > current.btm => brFVG.remove(i)
				stuff.top > current.top and stuff.btm < current.btm => brFVG.remove(i)
				stuff.top < current.top and stuff.top > current.btm => brFVG.remove(i)

	if blFVG.size() > 0 and brFVG.size() > 0
		for i       = blFVG.size() - 1 to 0
			stuff   = blFVG.get(i)
			current = brFVG.get(0)
			switch
				stuff.btm > current.btm and stuff.btm < current.top => blFVG.remove(i)
				stuff.top < current.top and stuff.btm > current.btm => blFVG.remove(i)
				stuff.top > current.top and stuff.btm < current.btm => blFVG.remove(i)
				stuff.top < current.top and stuff.top > current.btm => blFVG.remove(i)

	if blFVG.size() > 0 and brFVG.size() > 0
		for i       = brFVG.size() - 1 to 0
			stuff   = brFVG.get(i)
			current = blFVG.get(0)
			switch
				stuff.btm > current.btm and stuff.btm < current.top => brFVG.remove(i)
				stuff.top < current.top and stuff.btm > current.btm => brFVG.remove(i)
				stuff.top > current.top and stuff.btm < current.btm => brFVG.remove(i)
				stuff.top < current.top and stuff.top > current.btm => brFVG.remove(i)

method umt(ob metric) =>
	switch metric.dir
		1 =>
			switch metric.move
				1 => metric.blPOS := metric.blPOS + 1, metric.move := 2
				2 => metric.blPOS := metric.blPOS + 1, metric.move := 3
				3 => metric.brPOS := metric.brPOS + 1, metric.move := 1

		-1 =>
			switch metric.move
				1 => metric.brPOS := metric.brPOS + 1, metric.move := 2
				2 => metric.brPOS := metric.brPOS + 1, metric.move := 3
				3 => metric.blPOS := metric.blPOS + 1, metric.move := 1

	if (time - time[1]) == (time[1] - time[2])
		metric.xlocbl := metric.loc + (time - time[1]) * metric.blPOS
		metric.xlocbr := metric.loc + (time - time[1]) * metric.brPOS


method display(ob id, ob[] full, int i) =>
	if not id.isbb
		bin.bx.unshift(box.new    (top = id.top, bottom = id.btm, left = id.loc, right    = time      , border_color = na    , bgcolor = id.css, xloc = xloc.bar_time))
		bin.bx.unshift(box.new    (top = id.top, bottom = id.btm, left = time   , right   = time + 1  , border_color = na    , bgcolor = id.css, xloc = xloc.bar_time, extend = extend.right))

	else
		bin.bx.unshift(box.new    (top = id.top, bottom = id.btm, left = id.loc   , right = id.bbloc , border_color = na     , bgcolor = id.css                , xloc = xloc.bar_time))
		bin.bx.unshift(box.new    (top = id.top, bottom = id.btm, left = id.bbloc , right = time     , border_color = id.css , bgcolor = id.bull ? bbup : bbdn , xloc = xloc.bar_time, border_width = 2))
		bin.bx.unshift(box.new    (top = id.top, bottom = id.btm, left = time     , right = time + 1 , border_color = id.css , bgcolor = id.bull ? bbup : bbdn , xloc = xloc.bar_time, extend = extend.right))        

	if obshowactivity
		bin.bx.unshift(box.new    (top = id.top, bottom = id.avg, left = id.loc   , right = id.xlocbl, border_color = na     , bgcolor = obactup, xloc = xloc.bar_time))
		bin.bx.unshift(box.new    (top = id.avg, bottom = id.btm, left = id.loc   , right = id.xlocbr, border_color = na     , bgcolor = obactdn, xloc = xloc.bar_time))

	if showline
		bin.ln.unshift(line.new(
			   x1    = id.loc
			 , x2    = time
			 , y1    = id.avg
			 , y2    = id.avg
			 , color = color.new(id.css, 60)
			 , xloc  = xloc.bar_time
			 , style = line.style_dotted
			  )
			 )

	if showmetric
		if i == math.min(oblast - 1, full.size() - 1)
			float   tV = 0
			float[] dV = array.new<float>()
			seq       = math.min(oblast - 1, full.size() - 1)
			for j = 0 to seq
				cV = full.get(j)
				tV += cV.vol
				if j == seq
					for y = 0 to seq
						dV.push(
							 math.floor(
								 (full.get(y).vol / tV) * 100)
						 )
						ids = full.get(y)
						bin.lb.unshift(label.new(
							   bar_index - 1
							 , ids.avg
							 , textcolor = color.new(ids.css, 50)
							 , style     = label.style_label_left
							 , size      = obtxt.txSz()
							 , color     = #ffffff00
							 , text      = 
								 str.tostring(
									 math.round(full.get(y).vol, 3), format = format.volume) + " (" + str.tostring(dV.get(y)) + "%)"
								  )
								 )

method dispFVG(FVG fvg, int i, bool bull) =>
	ext = fvgextend ? extend.right : extend.none
	if not fvg.isbb
		bin.bx.unshift(box .new(top = fvg.top, bottom = fvg.btm, left = fvg.loc                 , right = time                   , border_color = na   , bgcolor = bull ? fvg_upcss : fvg_dncss            , xloc = xloc.bar_time, extend = ext))
		if fvgline
			bin.ln.unshift(line.new(x1  = fvg.loc, x2 = time       , y1 = math.avg(fvg.top, fvg.btm), y2 = math.avg(fvg.top, fvg.btm), xloc = xloc.bar_time, color = color.new(bull ? fvg_upcss : fvg_dncss, 0)                      , extend = ext))
		if dispraid
			bin.ln.unshift(line.new(x1  = fvg.raidloc, x2 = fvg.raidx2, y1 = fvg.raidy, y2 = fvg.raidy, xloc = xloc.bar_time, color = fvg.raidcs))
			bin.lb.unshift(label.new(x = int(math.avg(fvg.raidloc, fvg.raidx2)), y = fvg.raidy, text = "x", xloc = xloc.bar_time, textcolor = fvg.raidcs, style = bull ? label.style_label_up : label.style_label_down, size = size.small, color = #ffffff00))

	else
		bin.bx.unshift(box .new(top = fvg.top  , bottom = fvg.btm, left = fvg.loc                   , right = fvg.bbloc              , border_color = na                                 , bgcolor = bull ? fvg_upcss : fvg_dncss, xloc = xloc.bar_time))
		bin.bx.unshift(box .new(top = fvg.top  , bottom = fvg.btm, left = fvg.bbloc                 , right = time                   , border_color = bull ? fvg_dncss : fvg_upcss       , bgcolor = bull ? fvg_dncss : fvg_upcss, xloc = xloc.bar_time, extend = ext))
		if fvgline
			bin.ln.unshift(line.new(x1  = fvg.loc  , x2 = fvg.bbloc  , y1   = math.avg(fvg.top, fvg.btm), y2 = math.avg(fvg.top, fvg.btm), color = color.new(bull ? fvg_upcss : fvg_dncss, 0)                                        , xloc = xloc.bar_time))
			bin.ln.unshift(line.new(x1  = fvg.bbloc, x2 = time       , y1   = math.avg(fvg.top, fvg.btm), y2 = math.avg(fvg.top, fvg.btm), color = color.new(bull ? fvg_dncss : fvg_upcss, 0)                                        , xloc = xloc.bar_time, extend = ext, style = line.style_dashed))

//// ───────────────────────
/// ─── SmcB ────
/// ─── Functions ──
//// ───────────────────────

mapping() =>
	var float    up          = na
	var float    dn          = na
	var float point          = na
	var int   trend          = 0
	var int     idx          = na
	var int     sum          = na
	var int project          = na
	var chart.point[] charts = array.new<chart.point>()

	if na(up)
		up := high
		idx := bar_index

	if na(dn)
		dn := low
		idx := bar_index

	if high > up
		if trend == -1
			id = IDMIDX(false, idx)
			charts.unshift(
				 chart.point.from_time(
					   time[id]
					 , low [id]
					  )
					 )
			idx   := bar_index
			point := low [id]
			sum   := time[id]

		up      := high
		dn      := low
		project := time
		trend   := 1

	if low < dn
		if trend == 1
			id = IDMIDX(true, idx)
			charts.unshift(
				 chart.point.from_time(
					   time[id]
					 , high[id]
					  )
					 )
			idx   := bar_index
			point := high[id]
			sum   := time[id]

		up      := high
		dn      := low
		project := time
		trend := -1

	if barstate.islast
		var line     ln = na
		var polyline pl = na
		ln.delete()
		pl.delete()
		ln := na
		pl := na
		ln := line.new(
			   x1 = sum
			 , x2 = project
			 , y1 = point
			 , y2 = trend == 1 ? up : dn
			 , xloc = xloc.bar_time
			 , color = color.red
			 )
		pl := polyline.new(
			   charts
			 , line_color = mappingcss
			 , xloc = xloc.bar_time
			 , line_style = mappingStyle.lstyle()
			 )

posLIQ() =>
	ph = ta.pivothigh(high, 5, 5)
	pl = ta.pivotlow (low , 5, 5)

	var float[] lUp = array.new<float>(1, ph)
	var float[] lDn = array.new<float>(1, pl)

	var bool upallow = true
	var bool dnallow = true

	bool printup = false
	bool printdn = false

	if ph
		lUp.set(0, ph)
	
	if pl
		lDn.set(0, pl)


	if high > lUp.get(0) and close < lUp.get(0) and upallow and high > high[1]
		
		upallow := false
		printup := true
		

	if low  < lDn.get(0) and close > lDn.get(0) and dnallow and low < low[1]
		
		dnallow := false
		printdn := true
		

	if ph and upallow == false
		upallow := true
	
	if pl and dnallow == false
		dnallow := true

	[printup, printdn]

dEHL() =>
	var equalbuild[] bleqal = array.new<equalbuild>()
	var equalbuild[] breqal = array.new<equalbuild>()
	var equalname [] blname = array.new<equalname >()
	var equalname [] brname = array.new<equalname >()

	int                 pos  = 2
	float             thresh = 0.1
	switch ehlmode
		"Short-Term" => pos := 2, thresh := 0.1
		"Mid-Term"   => pos := 6, thresh := 0.25
		"Long-Term"  => pos := 10, thresh := 0.5

	var ehl w = ehl.new      (0 , 0 , 0 , 0)
	float top = ta .pivothigh(high, pos, pos)
	float btm = ta .pivotlow (low , pos, pos)
	float atr = ta .atr      (      200     )

	switch
		top =>
			mx = math.max(top, w.pt)
			mn = math.min(top, w.pt)
			switch
				mx < mn + atr * thresh =>
					bleqal.unshift(
						 equalbuild.new(
							   w.t
							 , w.pt
							 , bar_index - pos
							 , top
							 , ehlupcs
							 , line.style_dotted
							  )
							 )
					blname.unshift(
						 equalname.new(
							   int(math.avg(bar_index - pos, w.t))
							 , top
							 , "EQH"
							 , ehlupcs
							 , label.style_label_down
							  )
							 )
			w.pt := top
			w.t  := bar_index - pos

			

		btm =>
			mx = math.max(btm, w.pb)
			mn = math.min(btm, w.pb)
			switch
				mn > mx - atr * thresh =>
					breqal.unshift(
						 equalbuild.new(
							   w.b
							 , w.pb
							 , bar_index - pos
							 , btm
							 , ehldowncs, line.style_dotted
							  )
							 )
					brname.unshift(
						 equalname.new(
							   int(math.avg(bar_index - pos, w.b))
							 , btm
							 , "EQL"
							 , ehldowncs
							 , label.style_label_up
							  )
							 )
			w.pb := btm
			w.b  := bar_index - pos

			

	if barstate.islast
		if bleqal.size() > 0
			for i = 0 to bleqal.size() - 1
				draw = bleqal.get(i)
				labe = blname.get(i)
				if i < 10
					bin.ln.unshift(
						 line.new(
							   draw.x1
							 , draw.y1
							 , draw.x2
							 , draw.y2
							 , color = draw.css
							 , style = draw.style
							  )
							 )
					bin.lb.unshift(
						 label.new(
							   x         = labe.x
							 , y         = labe.y
							 , color     = #ffffff00
							 , style     = labe.style
							 , textcolor = labe.css
							 , size      = mstext.txSz()
							 , text      = labe.txt
							  )
							 )

		if breqal.size() > 0
			for i = 0 to breqal.size() - 1
				draw = breqal.get(i)
				labe = brname.get(i)
				if i < 10
					bin.ln.unshift(
						 line.new(
							   draw.x1
							 , draw.y1
							 , draw.x2
							 , draw.y2
							 , color = draw.css
							 , style = draw.style
							  )
							 )
					bin.lb.unshift(
						 label.new(
							   x         = labe.x
							 , y         = labe.y
							 , color     = #ffffff00
							 , style     = labe.style
							 , textcolor = labe.css
							 , size      = mstext.txSz()
							 , text      = labe.txt
							  )
							 )

method SFP(structure ms) =>

	h  = high
	h1 = high[1]
	h2 = high[2]
	l  = low
	l1 = low [1]
	l2 = low [2]
	c  = close
	v  = volume
	t  = time
	n  = bar_index
	t1 = time[1]

	string size  = devsize.txSz()
	bool     vol = (ta.sma(v, 21) * sfpthresh) < v ? true : false
	bool blPrint = true
	bool brPrint = true

	switch sfpfilter
		"Trend Following" =>
			switch ms.trend
				1  => blPrint := true  , brPrint := false
				-1 => blPrint := false , brPrint := true

		"Counter Trade" =>
			switch ms.trend
				1  => blPrint := false , brPrint := true
				-1 => blPrint := true  , brPrint := false

		=> na

	var SFP         [] BLsfp = array.new<    SFP     >()
	var SFP         [] BRsfp = array.new<    SFP     >()
	float           [] lg    = array.new<   float    >()
	int             [] tn    = array.new<    int     >()
	float           [] ac    = array.new<   float    >()
	var sfpbuildlbl [] BLlb  = array.new<sfpbuildlbl >()
	var sfpbuildlbl [] BRlb  = array.new<sfpbuildlbl >()
	var sfpbuildline[] BLln  = array.new<sfpbuildline>()
	var sfpbuildline[] BRln  = array.new<sfpbuildline>()

	if l > l1 and l1 < l2 and vol[1]
		BLsfp.clear()
		if spfuselen
			for i = 1 to sfplen
				lg.unshift(l[i])
				tn.unshift(t[i])
				ac.unshift(h[i])

			BLsfp.unshift(
				 SFP.new(
					   lg.min()
					 , tn.get(lg.indexof(lg.min()))
					 , ac.get(lg.indexof(lg.min()))
					  )
					 )

			if lg.min() != l1
				BLsfp.unshift(
					 SFP.new(
						 l1
						 , t1
						 , h1
						 )
						 )   

		else
			BLsfp.unshift(
				 SFP.new(
					   l1
					 , t1
					 , h1
					  )
					 )       

	if h < h1 and h1 > h2 and vol[1]
		BRsfp.clear()
		if spfuselen
			for i = 1 to sfplen
				lg.unshift(h[i])
				tn.unshift(t[i])
				ac.unshift(l[i])

			BRsfp.unshift(
				 SFP.new(
					   lg.max()
					 , tn.get(lg.indexof(lg.max()))
					 , ac.get(lg.indexof(lg.max()))
					  )
					 )

			if lg.max() != h1
				BRsfp.unshift(
					 SFP.new(
						 h1
						 , t1
						 , l1
						 )
						 )

		else
			BRsfp.unshift(
				 SFP.new(
					   h1
					 , t1
					 , l1
					  )
					 )

	if BLsfp.size() > 0 and blPrint
		for i = BLsfp.size() - 1 to 0
			sfp = BLsfp.get(i)
			switch
				c < sfp.y =>
					BLsfp.remove(i)

				l < sfp.y and c > sfp.y =>
					if vol
						
						BLlb.unshift(
							 sfpbuildlbl.new(
								 time
								 , (low < sfp.y ? low : sfp.y)
								 , label.style_label_up
								 , blsfpcs, "▲\nSFP"
								 )
								 )
						BLln.unshift(
							 sfpbuildline.new(
								 sfp.loc
								 , time
								 , sfp.y
								 , blsfpcs
								 , sfp.ancor
								 , bar_index
								 )
								 )

						BLsfp.remove(i)

					else
						BLsfp.remove(i)

	if BRsfp.size() > 0 and brPrint
		for i = BRsfp.size() - 1 to 0 
			sfp = BRsfp.get(i)
			switch
				c > sfp.y =>
					BRsfp.remove(i)

				h > sfp.y and c < sfp.y =>
					if vol
						
						BRlb.unshift(
							 sfpbuildlbl.new(
								 time
								 , (high > sfp.y ? high : sfp.y)
								 , label.style_label_down
								 , brsfpcs
								 , "SFP\n▼"
								 )
								 )
						BRln.unshift(
							 sfpbuildline.new(
								 sfp.loc
								 , time
								 , sfp.y
								 , brsfpcs
								 , sfp.ancor
								 , bar_index
								 )
								 )

						BRsfp.remove(i)

					else
						BRsfp.remove(i)

	if barstate.islast
		if sfpshow > 0 and BLlb.size() > 0
			for i = 0 to math.min(sfpshow - 1, BLlb.size() - 1)
				x = BLlb.get(i)
				bin.lb.unshift(
					 label.new(
						   x = x.x
						 , y = x.y
						 , text = x.txt
						 , color = #ffffff00
						 , style = x.style
						 , size = size
						 , textcolor = x.css
						 , xloc = xloc.bar_time
						  )
						 )      

		if sfpshow > 0 and BRlb.size() > 0
			for i = 0 to math.min(sfpshow - 1, BRlb.size() - 1)
				x = BRlb.get(i)
				bin.lb.unshift(
					 label.new(
						   x = x.x
						 , y = x.y
						 , text = x.txt
						 , color = #ffffff00
						 , style = x.style
						 , size = size
						 , textcolor = x.css
						 , xloc = xloc.bar_time
						  )
						 ) 

		if sfpshow > 0 and BLln.size() > 0
			for i = 0 to math.min(sfpshow - 1, BLln.size() - 1)
				x = BLln.get(i)
				bin.ln.unshift(
					 line.new(
						   x1 = x.x1
						 , x2 = x.x2
						 , y1 = x.y
						 , y2 = x.y
						 , color = x.css
						 , style = line.style_solid
						 , xloc = xloc.bar_time
						  )
						 ) 

		if sfpshow > 0 and BRln.size() > 0
			for i = 0 to math.min(sfpshow - 1, BRln.size() - 1)
				x = BRln.get(i)
				bin.ln.unshift(
					 line.new(
						   x1 = x.x1
						 , x2 = x.x2
						 , y1 = x.y
						 , y2 = x.y
						 , color = x.css
						 , style = line.style_solid
						 , xloc = xloc.bar_time
						  )
						 ) 

		if sfpshow > 0 and BLln.size() > 0 and BRln.size() > 0 and showdev
			max  = math.max(BLln.get(0).loc, BRln.get(0).loc)
			use  = math.max(BLln.get(0).loc, BRln.get(0).loc) == BLln.get(0).loc ? BLln.get(0) : BRln.get(0)
			bull = math.max(BLln.get(0).loc, BRln.get(0).loc) == BLln.get(0).loc ?        true : false
			switch bull
				false => 
					bin.ln.unshift(line.new(x1 = use.x1, x2 = time, y1 = use.ancor - 4.0 * (use.y - use.ancor), y2 = use.ancor - 4.0 * (use.y - use.ancor), xloc = xloc.bar_time, color = chart.fg_color, style = devstyle.lstyle()))
					bin.ln.unshift(line.new(x1 = use.x1, x2 = time, y1 = use.ancor - 2.0 * (use.y - use.ancor), y2 = use.ancor - 2.0 * (use.y - use.ancor), xloc = xloc.bar_time, color = devcss, style = devstyle.lstyle()))
					bin.ln.unshift(line.new(x1 = use.x1, x2 = time, y1 = use.ancor - 2.5 * (use.y - use.ancor), y2 = use.ancor - 2.5 * (use.y - use.ancor), xloc = xloc.bar_time, color = devcss, style = devstyle.lstyle()))
					if devfill
						bin.lf.unshift(
							 linefill.new(
								   bin.ln.get(0)
								 , bin.ln.get(1)
								 , color = color.new(devcss, 90)
								  )
								 )

					if devlvl
						bin.lb.unshift(label.new(x = use.x1, y = use.ancor + 4.0 * (use.ancor - use.y), text = str.tostring(4.0 * 100) + "%" + " (" + str.tostring(math.round(use.ancor + 4.0 * (use.ancor - use.y), 2)) + ")", style = label.style_label_right, textcolor = chart.fg_color, color = #ffffff00, size = devsize.txSz(), xloc = xloc.bar_time))
						bin.lb.unshift(label.new(x = use.x1, y = use.ancor + 2.0 * (use.ancor - use.y), text = str.tostring(2.0 * 100) + "%" + " (" + str.tostring(math.round(use.ancor + 2.0 * (use.ancor - use.y), 2)) + ")", style = label.style_label_right, textcolor = devcss        , color = #ffffff00, size = devsize.txSz(), xloc = xloc.bar_time))
						bin.lb.unshift(label.new(x = use.x1, y = use.ancor + 2.5 * (use.ancor - use.y), text = str.tostring(2.5 * 100) + "%" + " (" + str.tostring(math.round(use.ancor + 2.5 * (use.ancor - use.y), 2)) + ")", style = label.style_label_right, textcolor = devcss        , color = #ffffff00, size = devsize.txSz(), xloc = xloc.bar_time))

				true => 
					bin.ln.unshift(line.new(x1 = use.x1, x2 = time, y1 = use.ancor + 4.0 * (use.ancor - use.y), y2 = use.ancor + 4.0 * (use.ancor - use.y), xloc = xloc.bar_time, color = chart.fg_color, style = devstyle.lstyle()))
					bin.ln.unshift(line.new(x1 = use.x1, x2 = time, y1 = use.ancor + 2.0 * (use.ancor - use.y), y2 = use.ancor + 2.0 * (use.ancor - use.y), xloc = xloc.bar_time, color = devcss, style = devstyle.lstyle()))
					bin.ln.unshift(line.new(x1 = use.x1, x2 = time, y1 = use.ancor + 2.5 * (use.ancor - use.y), y2 = use.ancor + 2.5 * (use.ancor - use.y), xloc = xloc.bar_time, color = devcss, style = devstyle.lstyle()))
					if devfill
						bin.lf.unshift(
							 linefill.new(
								   bin.ln.get(0)
								 , bin.ln.get(1)
								 , color = color.new(devcss, 90)
								  )
								 )

					if devlvl
						bin.lb.unshift(label.new(x = use.x1, y = use.ancor + 4.0 * (use.ancor - use.y), text = str.tostring(4.0 * 100) + "%" + " (" + str.tostring(math.round(use.ancor + 4.0 * (use.ancor - use.y), 2)) + ")", style = label.style_label_right, textcolor = chart.fg_color, color = #ffffff00, size = devsize.txSz(), xloc = xloc.bar_time))
						bin.lb.unshift(label.new(x = use.x1, y = use.ancor + 2.0 * (use.ancor - use.y), text = str.tostring(2.0 * 100) + "%" + " (" + str.tostring(math.round(use.ancor + 2.0 * (use.ancor - use.y), 2)) + ")", style = label.style_label_right, textcolor = devcss, color = #ffffff00, size = devsize.txSz(), xloc = xloc.bar_time))
						bin.lb.unshift(label.new(x = use.x1, y = use.ancor + 2.5 * (use.ancor - use.y), text = str.tostring(2.5 * 100) + "%" + " (" + str.tostring(math.round(use.ancor + 2.5 * (use.ancor - use.y), 2)) + ")", style = label.style_label_right, textcolor = devcss, color = #ffffff00, size = devsize.txSz(), xloc = xloc.bar_time))


dFVG() =>
	[h2, l2, c1, o1, c, o, h, l, h1, l1, fvatr] = ghl()
	var FVG[] blFVG = array.new<FVG>()
	var FVG[] brFVG = array.new<FVG>()
	bool      upfvg = false
	bool      dnfvg = false
	float     blth  = l1 + (fvatr[1] * fvgthresh)
	float     brth  = h1 - (fvatr[1] * fvgthresh)

	cc    =                        timeframe.change()

	switch
		what_fvg == "FVG" or what_fvg == "Breakers" =>
			if l > h2 and cc and c1 > blth
				upfvg := true
				
			if l2 > h and cc and c1 < brth
				dnfvg := true


	if upfvg[1]
		if blFVG.size() > 0
			fvg = blFVG.get(0)
			if fvg.israid == true and fvg.active == false
				fvg.active  := true
				fvg.raidloc := na
				fvg.raidx2  := na
				fvg.raidy   := na
				fvg.raidcs  := #ffffff00

		blFVG.unshift(
			 FVG.new(
				   l   [1]
				 , h2  [1]
				 , time[3]
				 , false
				 , na
				  )
				 )

	if dnfvg[1]
		if brFVG.size() > 0
			fvg = brFVG.get(0)
			if fvg.israid == true and fvg.active == false
				fvg = brFVG.get(0)
				fvg.active := true
				fvg.active  := true
				fvg.raidloc := na
				fvg.raidx2  := na
				fvg.raidy   := na
				fvg.raidcs  := #ffffff00

		brFVG.unshift(
			 FVG.new(
				   l2  [1]
				 , h   [1]
				 , time[3]
				 , false
				 , na
				  )
				 )

	if blFVG.size() > 0
		for [i, fvg] in blFVG
			if not fvg.isbb
				if fvg_src      == "Cierre" ? math.min(c, o) < fvg.btm : fvg_src == "Mecha" ? l < fvg.btm : fvg_src == "Avg" ? l < math.avg(fvg.top, fvg.btm) : na
					fvg.isbb             := true
					fvg.bbloc            := time
					if what_fvg == "FVG"
						blFVG.remove(i)

			else
				if (fvg_src == "Cierre" ? math.max(c, o) > fvg.top : fvg_src == "Mecha" ? h > fvg.top : fvg_src == "Avg" ? h > math.avg(fvg.top, fvg.btm) : na) and what_fvg == "Breakers"
					blFVG.remove(i)

	if brFVG.size() > 0
		for [i, fvg] in brFVG
			if not fvg.isbb
				if (fvg_src     == "Cierre" ? math.max(c, o) > fvg.top : fvg_src == "Mecha" ? h > fvg.top : fvg_src == "Avg" ? h > math.avg(fvg.top, fvg.btm) : na)
					fvg.isbb             := true
					fvg.bbloc            := time
					if what_fvg == "FVG"
						brFVG.remove(i)
			else
				if (fvg_src == "Cierre" ? math.min(c, o) < fvg.btm : fvg_src == "Mecha" ? l < fvg.btm : fvg_src == "Avg" ? l < math.avg(fvg.top, fvg.btm) : na) and what_fvg == "Breakers"
					brFVG.remove(i)

	if fvgoverlap
		overlapFVG(blFVG, brFVG)


	if dispraid
		for [i, fvg] in blFVG
			if not fvg.israid and not fvg.isbb
				if low < fvg.top and close > fvg.top
					fvg.israid  := true
					fvg.raidloc := time
					fvg.raidx2  := time
					fvg.raidy   := low
					fvg.raidcs  := chart.fg_color
			else
				if low <= fvg.raidy and fvg.active == false and not fvg.isbb
					fvg.active := true
					fvg.raidx2 := time
				else
					if fvg.active == false and not fvg.isbb
						fvg.raidx2 := time

		for [i, fvg] in brFVG
			if not fvg.israid and not fvg.isbb
				if high > fvg.btm and close < fvg.btm and not fvg.isbb
					fvg.israid  := true
					fvg.raidloc := time
					fvg.raidy   := high
					fvg.raidx2  := time
					fvg.raidcs  := chart.fg_color
			else
				if high >= fvg.raidy and fvg.active == false and not fvg.isbb
					
					fvg.active := true
					fvg.raidx2 := time
				else
					if fvg.active == false and not fvg.isbb
						fvg.raidx2 := time

	if barstate.islast
		if blFVG.size() > 0 and fvg_num > 0
			for i = 0 to math.min(fvg_num - 1, blFVG.size() - 1)
				fvg = blFVG.get(i)
				dispFVG(fvg, i, true)

		if brFVG.size() > 0 and fvg_num > 0
			for i = 0 to math.min(fvg_num - 1, brFVG.size() - 1)
				fvg = brFVG.get(i)
				dispFVG(fvg, i, false)

structure(color upcss, color dncss, bool draw, bool internal, int limit) =>
	var structure ms  = structure.new(start = 0)
	var     ob     [] blob     = array.new<     ob    >()
	var     ob     [] brob     = array.new<     ob    >()
	var drawms     [] bldw     = array.new<  drawms   >()
	var drawms     [] brdw     = array.new<  drawms   >()
	var sellbuyside[] sellside = array.new<sellbuyside>()
	var sellbuyside[] buyside  = array.new<sellbuyside>()
	bool      crossup =     false
	bool      crossdn =     false
	var float up      =     na
	var float dn      =     na
	idbull            =  ms.find(false, false, true)
	idbear            =  ms.find(true , false, true)
	btmP              =  obmode == "Longitud" ? (high[idbear] - 1 * atr[idbear]) < low [idbear] ? low [idbear] : (high[idbear] - 1 * atr[idbear]) : low [idbear]
	topP              =  obmode == "Longitud" ? (low [idbull] + 1 * atr[idbull]) > high[idbull] ? high[idbull] : (low [idbull] + 1 * atr[idbull]) : high[idbull]
	atr               = ta.atr (200)
	buy               = low  + atr
	sel               = high - atr
	ph                = ta.pivothigh(high, mslen, mslen)
	pl                = ta.pivotlow (low , mslen, mslen)
	var int  [] phn   = array.new< int >(1, na)
	var int  [] pln   = array.new< int >(1, na)
	var float[] php   = array.new<float>(1, na)
	var float[] plp   = array.new<float>(1, na)

	if internal
		blob.clear()
		brob.clear()

	if ph
		phn.unshift(bar_index[mslen])
		php.unshift(high[mslen])

	if pl
		pln.unshift(bar_index[mslen])
		plp.unshift(low[mslen])

	if php.size() > 0
		if high > php.get(0)
			php.clear()
			phn.clear()

	if plp.size() > 0
		if low < plp.get(0)
			plp.clear()
			pln.clear()

	if na(up)
		up      := high

	if na(dn)
		dn      := low

	if high > up
		up      := high
		dn      := low
		crossup := true

	if low < dn
		up      := high
		dn      := low
		crossdn := true

	if ms.start == 0
		ms         := structure.new(bar_index, na, high, low , bar_index, bar_index, 0, 1, na, bar_index)
		if draw
			bldw.unshift(drawms.new(time, time, high     , "CHoCH"  , upcss, line.style_dashed))
			brdw.unshift(drawms.new(time, time, low      , "CHoCH"  , dncss, line.style_dashed))

	ms.upsweep := false
	ms.dnsweep := false

	if ms.start == 1
		switch
			low <= ms.choch and close >= ms.choch and buildsweep =>
				
				ms.dnsweep   := true
				ms.choch     := low
				ms.xloc      := bar_index
				if draw
					dw        = brdw.get(0)
					dw.x2    := time
					dw.style := line.style_dotted
					dw.txt   := "x"
					brdw.unshift(
						 drawms.new(
							   time
							 , time
							 , low
							 , "CHoCH"
							 , dncss
							 , line.style_dashed
							  )
							 )

				

			high >= ms.bos and close <= ms.bos and buildsweep =>
				
				ms.upsweep   := true
				ms.bos       := high
				ms.xloc      := bar_index
				if draw
					dw        = bldw.get(0)
					dw.x2    := time
					dw.style := line.style_dotted
					dw.txt   := "x"
					bldw.unshift(
						 drawms.new(
							   time
							 , time
							 , high
							 , "CHoCH"
							 , upcss
							 , line.style_dashed
							  )
							 )

			close <= ms.choch =>
				
				ms.txt       := "choch"
				lc.start := true
				lc.count := 0
				blob.fnOB(true, topP, idbull)
				ms.trend     := -1
				ms.choch     := ms.bos
				ms.bos       := na
				ms.start     := 2
				ms.loc       := bar_index
				ms.main      := low
				ms.temp      := ms.loc
				ms.xloc      := bar_index
				if draw
					dw        = brdw.get(0)
					dw.x2    := time
					dw.style := internal ? line.style_dashed : line.style_solid

			close >= ms.bos =>
				
				ms.txt       := "choch"
				lc.start := true
				lc.count := 0
				brob.fnOB(false, btmP, idbear)
				ms.trend     := 1
				ms.choch     := ms.choch
				ms.bos       := na
				ms.start     := 2
				ms.loc       := bar_index
				ms.main      := high
				ms.temp      := ms.loc
				ms.xloc      := bar_index
				if draw
					dw        = bldw.get(0)
					dw.x2    := time
					dw.style := internal ? line.style_dashed : line.style_solid

	if ms.start == 2
		switch ms.trend
			-1 =>
				if low <= ms.main
					ms.main     := low
					ms.temp     := bar_index 

				if bar_index % mslen * 2 == 0
					if not na(ms.bos) and msmode == "Puntos estrechos" and php.size() > 0
						if php.get(0) < ms.choch
							// ms.xloc  := phn.get(0)
							ms.choch := php.get(0)
							ms.loc   := phn.get(0)
							ms.xloc  := phn.get(0)
							ms.temp  := phn.get(0)
							if draw
								choch     = bldw.get(0)
								choch.x1 := time [bar_index - phn.get(0)]
								choch.x2 := time
								choch.y  := php.get(0)

				if na(ms.bos)
					if crossup and close > open and close[1] > open[1]
						ms.bos  := ms.main
						ms.loc  := ms.temp
						ms.xloc := ms.loc
						if draw
							brdw.unshift(
								 drawms.new(
									   time[bar_index - ms.loc]
									 , time
									 , low [bar_index - ms.loc]
									 , "BOS"
									 , dncss
									 , line.style_dashed
									  )
									 )

				if not na(ms.bos) and draw
					dw        = brdw.get(0)
					dw.x2    := time

				if draw
					choch     = bldw.get(0)
					choch.x2 := time

				switch
					low <= ms.bos and close >= ms.bos and not na(ms.bos) and buildsweep =>
						
						ms.dnsweep   := true
						ms.bos       := low
						if draw
							dw        = brdw.get(0)
							dw.x2    := time
							dw.style := line.style_dotted
							dw.txt   := "x"
							brdw.unshift(
								 drawms.new(
									   time
									 , time
									 , low
									 , "BOS"
									 , dncss
									 , line.style_dashed
									  )
									 )

						if showside
							id  = ms.find(true, true, true)
							btm = (high[id] - atr[id]) > low[id] ? (high[id] - atr[id]) : low[id]
							sellside.unshift(
								 sellbuyside.new(
									   high[id]
									 , btm
									 , time[id]
									 , sidesidecss
									 , "Sell Side"
									 , volume[id]
									  )
									 )

							brarea.normal       := false

						ms.xloc      := bar_index

					close <= ms.bos and not na(ms.bos) =>
						
						ms.txt       := "bos"
						ms.zz        := ms.bos
						ms.zn        := bar_index
						lc.start := true
						lc.count := 0
						brob.fnOB(false, btmP, idbear)
						id        = ms.find(true, false, false)
						ms.xloc  := bar_index
						ms.bos   := na
						ms.choch := high     [id]
						ms.loc   := bar_index[id]
						if draw
							dw        = brdw.get(0)
							dw.x2    := time
							dw.style := internal ? line.style_dashed : line.style_solid
							choch     = bldw.get(0)
							choch.x1 := time [id]
							choch.x2 := time
							choch.y  := high [id]

				switch
					high >= ms.choch and close <= ms.choch and buildsweep =>
						
						ms.upsweep   := true
						ms.choch     := high
						ms.xloc      := bar_index
						if draw
							dw        = bldw.get(0)
							dw.x2    := time
							dw.style := line.style_dotted
							dw.txt   := "x"
							bldw.unshift(
								 drawms.new(
									   time
									 , time
									 , high
									 , "CHoCH"
									 , upcss
									 , line.style_dashed
									  )
									 )


					close >= ms.choch =>
						
						ms.txt       := "choch"
						ms.zz        := ms.choch
						ms.zn        := bar_index
						lc.start := true
						lc.count := 0
						blob.fnOB(true, topP, idbull)
						id        = ms.find(false, false, false)
						switch
							na(ms.bos) => 
								ms.choch := low[id]
								if draw
									brdw.unshift(
										 drawms.new(
											  time
											 , time
											 , low
											 , "BOS"
											 , dncss
											 , line.style_dashed
											 )
											 )
									choch = brdw.get(0)
									choch.x1 := time[bar_index - ms.temp]
							=> ms.choch := ms.bos//low[id + 1] < low[id] ? low[id + 1] : low[id]
						ms.bos   := na
						ms.main  := high
						ms.trend := 1
						ms.loc   := bar_index
						ms.xloc  := bar_index
						ms.temp  := ms.loc
						if draw
							dw         = bldw.get(0)
							dw.x2     := time
							dw.txt    := "CHoCH"
							dw.style  := internal ? line.style_dashed : line.style_solid
							choch      = brdw.get(0)
							choch.x2  := time
							choch.y   := ms.choch
							choch.txt := "CHoCH"

						if showside
							id  = ms.find(false, true, true)
							top = (low[id] + atr[id]) < high[id] ? (low[id] + atr[id]) : high[id]
							buyside.unshift(
								 sellbuyside.new(
									   low[id]
									 , top
									 , time[id]
									 , buysidecss
									 , "Buy Side"
									 , volume[id]
									  )
									 )

									 
						ms.xloc       := bar_index
						
						blarea.normal := false

			1 =>
				if high >= ms.main
					ms.main     := high
					ms.temp     := bar_index

				if na(ms.bos)
					if crossdn and close < open and close[1] < open[1]
						ms.bos  := ms.main
						ms.loc  := ms.temp
						ms.xloc := ms.loc
						if draw
							bldw.unshift(
								 drawms.new(
									   time[bar_index - ms.loc]
									 , time
									 , high[bar_index - ms.loc]
									 , "BOS"
									 , upcss
									 , line.style_dashed
									  )
									 )

				if bar_index % mslen * 2 == 0
					if not na(ms.bos) and msmode == "Puntos estrechos" and plp.size() > 0
						if plp.get(0) > ms.choch
							// ms.xloc  := pln.get(0)
							ms.choch := plp.get(0)
							ms.loc   := pln.get(0)
							ms.xloc  := pln.get(0)
							ms.temp  := pln.get(0)
							// ms.loc   := pln.get(0)
							if draw
								choch     = brdw.get(0)
								choch.x1 := time [bar_index - pln.get(0)]
								choch.x2 := time
								choch.y  := plp.get(0)

				if not na(ms.bos) and draw
					dw         = bldw.get(0)
					dw.x2     := time

				if draw
					choch      = brdw.get(0)
					choch.x2  := time

				switch
					high >= ms.bos and close <= ms.bos and not na(ms.bos) and buildsweep =>
						
						ms.upsweep   := true
						ms.bos       := high
						if draw
							dw        = bldw.get(0)
							dw.x2    := time
							dw.style := line.style_dotted
							dw.txt   := "x"
							bldw.unshift(
								 drawms.new(
									   time
									 , time
									 , high
									 , "BOS"
									 , upcss
									 , line.style_dashed
									  )
									 )

						if showside
							id  = ms.find(false, true, true)
							top = (low[id] + atr[id]) < high[id] ? (low[id] + atr[id]) : high[id]
							buyside.unshift(
								 sellbuyside.new(
									   low[id]
									 , top
									 , time[id]
									 , buysidecss
									 , "Buy Side"
									 , volume[id]
									  )
									 )

							blarea .normal     := false

						ms.xloc      := bar_index

					close >= ms.bos and not na(ms.bos) =>
						
						ms.txt       := "bos"
						ms.zz        := ms.bos
						ms.zn        := bar_index
						lc.start := true
						lc.count := 0
						blob.fnOB(true, topP, idbull)
						id        = ms.find(false, false, false)
						ms.xloc  := bar_index
						ms.bos   := na
						ms.choch := low      [id]
						ms.loc   := bar_index[id]
						if draw
							dw        = bldw.get(0)
							dw.x2    := time
							dw.style := internal ? line.style_dashed : line.style_solid
							choch     = brdw.get(0)
							choch.x1 := time [id]
							choch.x2 := time
							choch.y  := low  [id]

				switch
					low  <= ms.choch and close >= ms.choch and buildsweep =>
						
						ms.dnsweep   := true
						ms.choch     := low
						ms.xloc      := bar_index
						if draw
							dw        = brdw.get(0)
							dw.x2    := time
							dw.style := line.style_dotted
							dw.txt   := "x"
							brdw.unshift(
								 drawms.new(
									   time
									 , time
									 , low
									 , "CHoCH"
									 , dncss
									 , line.style_dashed
									  )
									 )

					close <= ms.choch =>
						
						ms.txt       := "choch"
						ms.zz        := ms.choch
						ms.zn        := bar_index
						lc.start := true
						lc.count := 0
						brob.fnOB(false, btmP, idbear)
						id        = ms.find(true, false, false)
						switch
							na(ms.bos) => 
								ms.choch := high[id]
								if draw
									bldw.unshift(
										 drawms.new(
											   time
											 , time
											 , high
											 , "BOS"
											 , upcss
											 , line.style_dashed
											 )
											 )
									choch = bldw.get(0)
									choch.x1 := time[bar_index - ms.temp]
							=> ms.choch := ms.bos//high[id + 1] > high[id] ? high[id + 1] : high[id]
						ms.bos   := na
						ms.main  := low
						ms.trend := -1
						ms.loc   := bar_index
						ms.temp  := ms.loc
						if draw
							dw         = brdw.get(0)
							dw.x2     := time
							dw.txt    := "CHoCH"
							dw.style  := internal ? line.style_dashed : line.style_solid
							choch      = bldw.get(0)
							choch.y   := ms.choch
							choch.x2  := time
							choch.txt := "CHoCH"

						if showside
							id  = ms.find(true, true, true)
							btm = (high[id] - atr[id]) > low[id] ? (high[id] - atr[id]) : low[id]
							sellside.unshift(
								 sellbuyside.new(
									   high[id]
									 , btm
									 , time[id]
									 , sidesidecss
									 , "Sell Side"
									 , volume[id]
									  )
									 )

							brarea .normal      := false
									 
						ms.xloc       := bar_index

	if showside
		if buyside.size() > 0
			side = buyside.get(0)
			if low < side.btm
				
				if blarea.normal == false
					blarea .normal           := true

			if close < side.top
				buyside.remove(0)

		if sellside.size() > 0
			side = sellside.get(0)
			if high > side.btm
				if brarea.normal == false
					brarea .normal           := true

			if close > side.top
				sellside.remove(0)

	if barstate.islast and showside
		if buyside.size() > 0
			side      = buyside.get(0)
			float sum = side.vol
			if buyside.size() > 0 and sellside.size() > 0
				sum  := buyside.get(0).vol + sellside.get(0).vol

			if sidemode == "Area"
				bin.bx.unshift(
						 box.new(
							   top          = side.top
							 , bottom       = side.btm
							 , left         = side.loc
							 , right        = time
							 , border_color = na
							 , bgcolor      = side.css
							 , xloc         = xloc.bar_time
							  )
							 )

			bin.ln.unshift(
					 line.new(
						   x1    = side.loc
						 , x2    = time
						 , y1    = side.top
						 , y2    = side.top
						 , xloc  = xloc.bar_time
						 , color = color.new(side.css, 0)
						 , style = line.style_solid
						  )
						 )
			bin.ln.unshift(
					 line.new(
						   x1    = bar_index
						 , x2    = bar_index + 10
						 , y1    = side.top
						 , y2    = side.top
						 , xloc  = xloc.bar_index
						 , color = color.new(side.css, 0)
						 , style = line.style_dotted
						  )
						 )

			bin.lb.unshift(
					 label.new(
						   x         = bar_index
						 , y         = side.top
						 , color     = #ffffff00
						 , style     = label.style_label_up
						 , textcolor = color.new(side.css, 0)
						 , size      = mstext.txSz()
						 , text      = "Buyside - " + str.tostring(math.floor((side.vol / sum) * 100)) + "%"
						  )
						 )

		if sellside.size() > 0
			side      = sellside.get(0)
			float sum = side.vol
			if buyside.size() > 0 and sellside.size() > 0
				sum  := buyside.get(0).vol + sellside.get(0).vol

			if sidemode == "Area"
				bin.bx.unshift(
						 box.new(
							 top          = side.top
							 , bottom       = side.btm
							 , left         = side.loc
							 , right        = time
							 , border_color = na
							 , bgcolor      = side.css
							 , xloc         = xloc.bar_time
							  )
							 )

			bin.ln.unshift(
					 line.new(
						   x1    = side.loc
						 , x2    = time
						 , y1    = side.top
						 , y2    = side.top
						 , xloc  = xloc.bar_time
						 , color = color.new(side.css, 0)
						 , style = line.style_solid
						  )
						 )
			bin.ln.unshift(
					 line.new(
						   x1    = bar_index
						 , x2    = bar_index + 10
						 , y1    = side.top
						 , y2    = side.top
						 , xloc  = xloc.bar_index
						 , color = color.new(side.css, 0)
						 , style = line.style_dotted
						  )
						 )

			bin.lb.unshift(
					 label.new(
						   x         = bar_index
						 , y         = side.top
						 , color     = #ffffff00
						 , style     = label.style_label_down
						 , textcolor = color.new(side.css, 0)
						 , size      = mstext.txSz()
						 , text      = "Sellside - "+ str.tostring(math.floor((side.vol / sum) * 100)) + "%"
						  )
						 )

	if blob.size() > 0
		ob = blob.get(0)
		if not ob.isbb
			if low  < ob.top
				if blobenter.normal       == false
					blobenter.normal       := true
		else
			if high > ob.btm
				if blobenter.breaker      == false
					blobenter.breaker      := true

	if brob.size() > 0
		ob = brob.get(0)
		if not ob.isbb
			if high > ob.btm
				if brobenter.normal        == false
					brobenter.normal       := true
		else
			if low  < ob.top
				if brobenter.breaker      == false
					brobenter.breaker      := true


	if obshow and oblast > 0
		if barstate.isconfirmed
			blob.mitigated()
			brob.mitigated()
			if overlap 
				overlap(blob, brob)

		if blob.size() > 0
			for [i, metric] in blob
				metric.umt()

		if brob.size() > 0
			for [i, metric] in brob
				metric.umt()

		if barstate.islast
			if blob.size() > 0
				for i = 0 to math.min(oblast - 1, blob.size() - 1)
					obs = blob.get(i)
					display(obs, blob, i)

			if brob.size() > 0
				for i = 0 to math.min(oblast - 1, brob.size() - 1)
					obs = brob.get(i)
					display(obs, brob, i)

	if barstate.islast and draw and bldw.size() > 0 and brdw.size() > 0
		for i = 0 to bldw.size() - 1
			obj = bldw.get(i)
			if i <= limit
				bin.ln.unshift(
					 line.new(
						   x1    = obj.x1
						 , x2    = obj.x2
						 , y1    = obj.y
						 , y2    = obj.y
						 , color = obj.css
						 , style = obj.style
						 , xloc  = xloc.bar_time
						  )
						 )
				bin.lb.unshift(
					 label.new(
						   x         = int(math.avg(bin.ln.get(0).get_x1(), bin.ln.get(0).get_x2()))
						 , y         = obj.y
						 , xloc      = xloc.bar_time
						 , color     = #ffffff00
						 , style     = label.style_label_down
						 , textcolor = obj.css
						 , size      = mstext.txSz()
						 , text      = obj.txt
						  )
						 )

				if msbubble
					bin.lb.unshift(
						 label.new(
							   x     = obj.x1
							 , y     = obj.y
							 , xloc  = xloc.bar_time
							 , color = color.new(obj.css, 80)
							 , style = label.style_circle
							 , size  = size.tiny
							  )
							 )

		for i = 0 to brdw.size() - 1
			obj = brdw.get(i)
			if i <= limit
				bin.ln.unshift(
					 line.new(
						   x1    = obj.x1
						 , x2    = obj.x2
						 , y1    = obj.y
						 , y2    = obj.y
						 , color = obj.css
						 , style = obj.style
						 , xloc  = xloc.bar_time
						  )
						 )
				bin.lb.unshift(
					 label.new(
						   x         = int(math.avg(bin.ln.get(0).get_x1(), bin.ln.get(0).get_x2()))
						 , y         = obj.y
						 , xloc      = xloc.bar_time
						 , color     = #ffffff00
						 , style     = label.style_label_up
						 , textcolor = obj.css
						 , size      = mstext.txSz()
						 , text      = obj.txt
						  )
						 )

				if msbubble
					bin.lb.unshift(
							 label.new(
								   x     = obj.x1
								 , y     = obj.y
								 , xloc  = xloc.bar_time
								 , color = color.new(obj.css, 80)
								 , style = label.style_circle
								 , size  = size.tiny
								  )
								 )

	ms

//// ───────────────────────
/// ─── SmcB ────
/// ─── Executions ──
//// ───────────────────────

structure      ms = na

if windowsis
	if (bar_index > last_bar_index - mswindow)
		ms := structure(swingcssup , swingcssdn , showSwing   , false, swingLimit)
if windowsis == false
	ms := structure(swingcssup , swingcssdn , showSwing   , false, swingLimit)

// if showInternal and inZone
//     structure ims = structure(interncssup, interncssdn, showInternal, true , swingLimit)


color css  = na

method darkcss(color css, float factor) =>

	blue  = color.b(css) * (1 - factor)
	red   = color.r(css) * (1 - factor)
	green = color.g(css) * (1 - factor)

	color.rgb(red, green, blue, 0)
	
if windowsis ? (bar_index > last_bar_index - mswindow) : true
	css := ms.trend == 1 ? swingcssup : swingcssdn
	css := (ms.txt == "bos" ? css : css.darkcss(0.3))


barcolor(candlecss ? css : na)


if lc.start and showzone and (windowsis ? (bar_index > last_bar_index - mswindow) : true)

	v = close > open ? volume : -volume

	switch ms.trend
		-1 =>
			if lc.count <= zonethresh
				if high > ms.zz and close < ms.zz
					lc.count := 0
				if close > ms.zz
					
					lc.start := false
					lc.count := 0
					float[] pp = array.new<float>()
					for i = 0 to bar_index - ms.zn
						pp.unshift(low[i])

					box.new(top = ms.zz, bottom = pp.min(), left = ms.zn - 1, right = bar_index + 1, border_color = na, bgcolor = dnzone)
					line.new(x1 = ms.zn, x2 = bar_index, y1 = ms.zz, y2 = ms.zz, color = swingcssdn, style = line.style_dotted)
					
		1 =>
			if lc.count <= zonethresh
				if low < ms.zz and close > ms.zz
					lc.count := 0
				if close < ms.zz
					
					lc.start := false
					lc.count := 0
					float[] pp = array.new<float>()
					for i = 0 to bar_index - ms.zn
						pp.unshift(high[i])

					box.new(top = pp.max(), bottom = ms.zz, left = ms.zn - 1, right = bar_index + 1, border_color = na, bgcolor = upzone)
					line.new(x1 = ms.zn, x2 = bar_index, y1 = ms.zz, y2 = ms.zz, color = swingcssup, style = line.style_dotted)

	if lc.count > zonethresh
		lc.start := false
		lc.count := 0


	lc.count += 1

if fvg_enable
	dFVG()

if windowsis ? (bar_index > last_bar_index - mswindow) : true
	if dispSFP
		ms.SFP()

if ehlshow
	dEHL()

if showMapping
	mapping()

[uLIQ, dLIQ] = posLIQ()

plotcandle(high, high, math.max(close, open), math.max(close, open), color = na, wickcolor = na, bordercolor = uLIQ and liqprint ? printupcs   : na)
plotcandle(low , low , math.min(close, open), math.min(close, open), color = na, wickcolor = na, bordercolor = dLIQ and liqprint ? printdowncs : na)

var phl = Zphl.new(
   na
 , na
 , label.new(na , na , color = invcol , textcolor = swingcssdn , style = label.style_label_down , size = size.tiny , text = "")
 , label.new(na , na , color = invcol , textcolor = swingcssup , style = label.style_label_up   , size = size.tiny , text = "")
 , true
 , true
 , true
 , true
 , ""
 , ""
 , 0
 , 0
 , 0
 , 0
 , high
 , low
 , 0
 , 0
 , 0
 , 0
 , 0
 , 0
 , na
 , na
 )
